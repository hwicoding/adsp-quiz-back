name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:  # 수동 실행 가능

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -p ${{ secrets.SERVER_PORT || '22' }} -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts || true
          chmod 600 ~/.ssh/known_hosts

      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PORT: ${{ secrets.SERVER_PORT || '22' }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile=~/.ssh/known_hosts -p ${SERVER_PORT} ${SERVER_USER}@${SERVER_HOST} << 'ENDSSH'
            set -e
            
            PROJECT_DIR="/opt/adsp-quiz-backend"
            ENV_FILE="${PROJECT_DIR}/env/.env"
            
            echo "=== GitHub Actions 배포 시작 ==="
            
            # 1. 프로젝트 디렉토리로 이동
            cd "$PROJECT_DIR"
            
            # 2. 최신 코드 가져오기
            echo "최신 코드 가져오기..."
            git fetch origin
            git reset --hard origin/main
            # data/postgres/ 디렉토리를 제외하고 정리 (데이터 보호)
            git clean -fd --exclude='data/postgres' || true
            
            # 3. 환경변수 파일 확인 (없으면 생성)
            if [ ! -f "$ENV_FILE" ]; then
              echo "환경변수 파일이 없습니다. 템플릿에서 생성합니다..."
              if [ -f "${PROJECT_DIR}/env/.env.template" ]; then
                cp "${PROJECT_DIR}/env/.env.template" "$ENV_FILE"
                chmod 600 "$ENV_FILE"
              else
                echo "템플릿 파일이 없습니다. 수동으로 생성해야 합니다."
                exit 1
              fi
            fi
            
            # 4. 환경변수 업데이트 (GitHub Secrets에서)
            echo "환경변수 업데이트..."
            
            # BOM 제거 (UTF-8 BOM이 있으면 제거)
            if [ -f "$ENV_FILE" ]; then
              # Python을 사용하여 BOM 제거 (heredoc 중첩 방지를 위해 인라인 명령어 사용)
              if command -v python3 &> /dev/null; then
                python3 -c "import sys; content = open('$ENV_FILE', 'rb').read(); open('$ENV_FILE', 'wb').write(content[3:]) if content.startswith(b'\xef\xbb\xbf') else None" 2>/dev/null || true
              else
                # sed를 사용하여 BOM 제거 (대안)
                sed -i '1s/^\xEF\xBB\xBF//' "$ENV_FILE" 2>/dev/null || true
              fi
            fi
            
            # 환경변수 값을 변수에 저장 및 export
            DATABASE_URL="${{ secrets.DATABASE_URL }}"
            DB_USER="${{ secrets.DB_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY || '' }}"
            SECRET_KEY="${{ secrets.SECRET_KEY }}"
            ALLOWED_ORIGINS="${{ secrets.ALLOWED_ORIGINS }}"
            
            export DATABASE_URL DB_USER DB_PASSWORD GEMINI_API_KEY SECRET_KEY ALLOWED_ORIGINS
            export ENV_FILE
            
            # Python 스크립트를 사용하여 환경변수 파일 업데이트 (특수 문자 처리 안전)
            # YAML 파서 오류 방지를 위해 한 줄로 작성
            python3 -c "import re, sys, os; env_file = os.environ['ENV_FILE']; database_url = os.environ['DATABASE_URL']; db_user = os.environ['DB_USER']; db_password = os.environ['DB_PASSWORD']; gemini_api_key = os.environ.get('GEMINI_API_KEY', ''); secret_key = os.environ['SECRET_KEY']; allowed_origins = os.environ['ALLOWED_ORIGINS']; content = open(env_file, 'r', encoding='utf-8').read(); def update_env_var(content, var_name, var_value): pattern = rf'^{re.escape(var_name)}=.*$'; replacement = f'{var_name}={var_value}'; return re.sub(pattern, replacement, content, flags=re.MULTILINE) if re.search(pattern, content, re.MULTILINE) else (content + ('\n' if content and not content.endswith('\n') else '') + f'{replacement}\n'); content = update_env_var(content, 'DATABASE_URL', database_url); content = update_env_var(content, 'DB_USER', db_user); content = update_env_var(content, 'DB_PASSWORD', db_password); content = update_env_var(content, 'GEMINI_API_KEY', gemini_api_key); content = update_env_var(content, 'SECRET_KEY', secret_key); content = update_env_var(content, 'ALLOWED_ORIGINS', allowed_origins); content = update_env_var(content, 'ENVIRONMENT', 'production'); content = update_env_var(content, 'PORT', '8001'); open(env_file, 'w', encoding='utf-8', newline='\n').write(content); print('✅ 환경변수 업데이트 완료')"
            
            echo "✅ 환경변수 업데이트 완료"
            
            # 5. 배포 스크립트 실행
            echo "=== 배포 스크립트 확인 ==="
            if [ -f "${PROJECT_DIR}/scripts/deploy.sh" ]; then
              echo "✅ 배포 스크립트 발견: ${PROJECT_DIR}/scripts/deploy.sh"
              echo "배포 스크립트 실행 중..."
              chmod +x "${PROJECT_DIR}/scripts/deploy.sh"
              
              if ! "${PROJECT_DIR}/scripts/deploy.sh"; then
                echo "❌ 배포 스크립트 실행 실패"
                exit 1
              fi
              
              echo "✅ 배포 스크립트 실행 완료"
            else
              echo "⚠️  배포 스크립트가 없습니다. 수동 배포를 진행합니다..."
              echo "수동 배포 시작..."
              
              # 수동 배포
              docker-compose --env-file "$ENV_FILE" down || true
              docker-compose --env-file "$ENV_FILE" build --no-cache
              docker-compose --env-file "$ENV_FILE" up -d
              
              # 컨테이너 시작 대기
              sleep 10
              
              # 마이그레이션 파일 확인 (임시 조치 - Dockerfile 수정 후 제거 가능)
              if ! docker-compose --env-file "$ENV_FILE" exec -T app test -d /app/migrations/versions 2>/dev/null; then
                echo "⚠️  마이그레이션 디렉토리가 없습니다. 확인이 필요합니다."
                docker-compose --env-file "$ENV_FILE" exec -T app ls -la /app/ || true
                docker-compose --env-file "$ENV_FILE" exec -T app ls -la /app/migrations/ 2>/dev/null || echo "migrations 디렉토리가 없습니다."
              fi
              
              # 마이그레이션 실행 (실패 시 배포 실패)
              if ! docker-compose --env-file "$ENV_FILE" exec -T app alembic upgrade head; then
                echo "❌ 마이그레이션 실패"
                echo "마이그레이션 로그:"
                docker-compose --env-file "$ENV_FILE" logs app | tail -20
                exit 1
              fi
              
              echo "✅ 수동 배포 완료"
            fi
            
            # 6. 헬스체크
            echo "=== 헬스체크 시작 ==="
            HEALTH_CHECK_URL="https://adsp-api.livbee.co.kr/health"
            MAX_RETRIES=5
            RETRY_DELAY=10
            
            for i in $(seq 1 $MAX_RETRIES); do
              echo "헬스체크 시도 $i/$MAX_RETRIES..."
              sleep $RETRY_DELAY
              
              HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" || echo "000")
              echo "헬스체크 응답: HTTP $HEALTH_RESPONSE"
              
              if [ "$HEALTH_RESPONSE" = "200" ]; then
                echo "✅ 배포 성공! 헬스체크 통과 (HTTP $HEALTH_RESPONSE)"
                break
              else
                if [ $i -eq $MAX_RETRIES ]; then
                  echo "❌ 헬스체크 실패 (최대 재시도 횟수 도달)"
                  echo "최종 응답 코드: HTTP $HEALTH_RESPONSE"
                  echo "애플리케이션 로그:"
                  docker-compose --env-file "$ENV_FILE" logs app | tail -50
                  echo "컨테이너 상태:"
                  docker-compose --env-file "$ENV_FILE" ps
                  exit 1
                else
                  echo "⚠️  헬스체크 실패 (HTTP $HEALTH_RESPONSE), 재시도 중..."
                fi
              fi
            done
            
            echo "=== 배포 완료 ==="
          ENDSSH

      - name: Deployment status
        if: success()
        run: |
          echo "✅ 배포가 성공적으로 완료되었습니다!"
          echo "애플리케이션 URL: https://adsp-api.livbee.co.kr"

      - name: Deployment failed
        if: failure()
        run: |
          echo "❌ 배포가 실패했습니다. 서버 로그를 확인하세요."
