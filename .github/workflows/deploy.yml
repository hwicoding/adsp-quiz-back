name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:  # 수동 실행 가능

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -p ${{ secrets.SERVER_PORT || '22' }} -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts || true
          chmod 600 ~/.ssh/known_hosts

      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PORT: ${{ secrets.SERVER_PORT || '22' }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile=~/.ssh/known_hosts -p ${SERVER_PORT} ${SERVER_USER}@${SERVER_HOST} << 'ENDSSH'
            set -e
            
            PROJECT_DIR="/opt/adsp-quiz-backend"
            ENV_FILE="${PROJECT_DIR}/env/.env"
            
            echo "=== GitHub Actions 배포 시작 ==="
            
            # 1. 프로젝트 디렉토리로 이동
            cd "$PROJECT_DIR"
            
            # 2. 최신 코드 가져오기
            echo "최신 코드 가져오기..."
            git fetch origin
            git reset --hard origin/main
            # data/postgres/ 디렉토리를 제외하고 정리 (데이터 보호)
            git clean -fd --exclude='data/postgres' || true
            
            # 3. 환경변수 파일 확인 (없으면 생성)
            if [ ! -f "$ENV_FILE" ]; then
              echo "환경변수 파일이 없습니다. 템플릿에서 생성합니다..."
              if [ -f "${PROJECT_DIR}/env/.env.template" ]; then
                cp "${PROJECT_DIR}/env/.env.template" "$ENV_FILE"
                chmod 600 "$ENV_FILE"
              else
                echo "템플릿 파일이 없습니다. 수동으로 생성해야 합니다."
                exit 1
              fi
            fi
            
            # 4. 환경변수 업데이트 (GitHub Secrets에서)
            echo "환경변수 업데이트..."
            
            # BOM 제거 (UTF-8 BOM이 있으면 제거)
            if [ -f "$ENV_FILE" ]; then
              # Python을 사용하여 BOM 제거 (heredoc 중첩 방지를 위해 인라인 명령어 사용)
              if command -v python3 &> /dev/null; then
                python3 -c "import sys; content = open('$ENV_FILE', 'rb').read(); open('$ENV_FILE', 'wb').write(content[3:]) if content.startswith(b'\xef\xbb\xbf') else None" 2>/dev/null || true
              else
                # sed를 사용하여 BOM 제거 (대안)
                sed -i '1s/^\xEF\xBB\xBF//' "$ENV_FILE" 2>/dev/null || true
              fi
            fi
            
            # 환경변수 값을 변수에 저장 및 export
            DATABASE_URL="${{ secrets.DATABASE_URL }}"
            DB_USER="${{ secrets.DB_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY || '' }}"
            SECRET_KEY="${{ secrets.SECRET_KEY }}"
            ALLOWED_ORIGINS="${{ secrets.ALLOWED_ORIGINS }}"
            
            export DATABASE_URL DB_USER DB_PASSWORD GEMINI_API_KEY SECRET_KEY ALLOWED_ORIGINS
            export ENV_FILE
            
            # Python 스크립트를 사용하여 환경변수 파일 업데이트 (특수 문자 처리 안전)
            # heredoc 중첩 방지를 위해 Python 원라이너 사용 (walrus operator로 반복문 처리)
            python3 -c "import re, os, sys; sys.stdout.reconfigure(encoding='utf-8') if sys.stdout.encoding != 'utf-8' else None; f = os.environ['ENV_FILE']; c = open(f, 'r', encoding='utf-8').read(); vars_list = [('DATABASE_URL', os.environ['DATABASE_URL']), ('DB_USER', os.environ['DB_USER']), ('DB_PASSWORD', os.environ['DB_PASSWORD']), ('GEMINI_API_KEY', os.environ.get('GEMINI_API_KEY', '')), ('SECRET_KEY', os.environ['SECRET_KEY']), ('ALLOWED_ORIGINS', os.environ['ALLOWED_ORIGINS']), ('ENVIRONMENT', 'production'), ('PORT', '8001')]; [c := (re.sub(rf'^{re.escape(n)}=.*$', f'{n}={v}', c, flags=re.MULTILINE) if re.search(rf'^{re.escape(n)}=.*$', c, re.MULTILINE) else (c + ('\n' if c and not c.endswith('\n') else '') + f'{n}={v}\n')) for n, v in vars_list]; open(f, 'w', encoding='utf-8', newline='\n').write(c); print('✅ 환경변수 업데이트 완료')"
            
            # 5. 배포 스크립트 실행
            echo "=== 배포 스크립트 확인 ==="
            if [ -f "${PROJECT_DIR}/scripts/deploy.sh" ]; then
              echo "✅ 배포 스크립트 발견: ${PROJECT_DIR}/scripts/deploy.sh"
              echo "배포 스크립트 실행 중..."
              chmod +x "${PROJECT_DIR}/scripts/deploy.sh"
              
              if ! "${PROJECT_DIR}/scripts/deploy.sh"; then
                echo "❌ 배포 스크립트 실행 실패"
                exit 1
              fi
              
              echo "✅ 배포 스크립트 실행 완료"
            else
              echo "⚠️  배포 스크립트가 없습니다. 수동 배포를 진행합니다..."
              echo "수동 배포 시작..."
              
              # 수동 배포
              docker-compose --env-file "$ENV_FILE" down || true
              docker-compose --env-file "$ENV_FILE" build --no-cache
              docker-compose --env-file "$ENV_FILE" up -d
              
              # 컨테이너 시작 대기
              sleep 10
              
              # 마이그레이션 파일 확인 (임시 조치 - Dockerfile 수정 후 제거 가능)
              if ! docker-compose --env-file "$ENV_FILE" exec -T app test -d /app/migrations/versions 2>/dev/null; then
                echo "⚠️  마이그레이션 디렉토리가 없습니다. 확인이 필요합니다."
                docker-compose --env-file "$ENV_FILE" exec -T app ls -la /app/ || true
                docker-compose --env-file "$ENV_FILE" exec -T app ls -la /app/migrations/ 2>/dev/null || echo "migrations 디렉토리가 없습니다."
              fi
              
              # 마이그레이션 실행 (실패 시 배포 실패)
              if ! docker-compose --env-file "$ENV_FILE" exec -T app alembic upgrade head; then
                echo "❌ 마이그레이션 실패"
                echo "마이그레이션 로그:"
                docker-compose --env-file "$ENV_FILE" logs app | tail -20
                exit 1
              fi
              
              echo "✅ 수동 배포 완료"
            fi
            
            # 6. 헬스체크
            echo "=== 헬스체크 시작 ==="
            HEALTH_CHECK_URL="https://adsp-api.livbee.co.kr/health"
            MAX_RETRIES=5
            RETRY_DELAY=10
            
            for i in $(seq 1 $MAX_RETRIES); do
              echo "헬스체크 시도 $i/$MAX_RETRIES..."
              sleep $RETRY_DELAY
              
              HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" || echo "000")
              echo "헬스체크 응답: HTTP $HEALTH_RESPONSE"
              
              if [ "$HEALTH_RESPONSE" = "200" ]; then
                echo "✅ 배포 성공! 헬스체크 통과 (HTTP $HEALTH_RESPONSE)"
                break
              else
                if [ $i -eq $MAX_RETRIES ]; then
                  echo "❌ 헬스체크 실패 (최대 재시도 횟수 도달)"
                  echo "최종 응답 코드: HTTP $HEALTH_RESPONSE"
                  echo "애플리케이션 로그:"
                  docker-compose --env-file "$ENV_FILE" logs app | tail -50
                  echo "컨테이너 상태:"
                  docker-compose --env-file "$ENV_FILE" ps
                  exit 1
                else
                  echo "⚠️  헬스체크 실패 (HTTP $HEALTH_RESPONSE), 재시도 중..."
                fi
              fi
            done
            
            echo "=== 배포 완료 ==="
          ENDSSH

      - name: Deployment status
        if: success()
        run: |
          echo "✅ 배포가 성공적으로 완료되었습니다!"
          echo "애플리케이션 URL: https://adsp-api.livbee.co.kr"

      - name: Deployment failed
        if: failure()
        run: |
          echo "❌ 배포가 실패했습니다. 서버 로그를 확인하세요."
